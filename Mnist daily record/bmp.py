# 预备实现功能：
#
# 　　1、读取bmp文件
#
# 　　2、保存bmp文件
#
# 　　3、对bmp图片进行放大、缩小
#
# 　　4、对bmp图片进行灰度化
#
# 　　5、对bmp图片进行旋转


# 　  1、http://blog.csdn.net/lanbing510/article/details/8176231
#     2、http://blog.csdn.net/jemenchen/article/details/52658476    各种图片编码格式详解
#     3,https://www.cnblogs.com/zyp4614/p/6917943.html


#R,G,B每个分量一般是用一个字节(8位)来表示，所以图(1)中每个像素大小就是3*8=24位图, 而图(2)中每个像素大小是4*8=32位
'''
图像是二维数据，数据在内存中只能一维存储，二维转一维有不同的对应方式。比较常见的只有两种方式: 按像素“行排列”从上往下或者从下往上
前一种是以计算机图形学的屏幕坐标系为参考(右上为原点,y轴向下 )，而另后一种是以标准的数学坐标系为参考(右下为原点,y轴向上)。
这两个坐标系只是y值不一样，互相转换的公式为:

y2 = height-1-y1

y1,y2分别为像素在两个坐标系中的y坐标，height为图像的高度。

bmp图片格式以及windows下的GDI，GDI+是从下往上排列，
其它比如DirectX,OpenGL,Cocoa(NSImage, UIImage),OpenCV等都是从上往下排列。
'''

'''
三、像素32位对齐
如果是RGB24位图，会存在一个32位对齐的问题——
在x86体系下，cpu一次处理32整数倍的数据会更快，图像处理中经常会按行为单位来处理像素。
24位图，宽度不是4的倍数时，其行字节数将不是32整数倍。这时可以采取在行尾添加冗余数据的方式，使其行字节数为32的倍数。
比如，如果图像宽为5像素，不做32位对齐的话，其行位数为24*5=120，120不是32的倍数。
是32整数倍并且刚好比120大的数是128，也就只需要在其行尾添加1字节(8位)的冗余数据即可。(一个以空间换时间的例子)
有个公式可以轻松计算出32位对齐后每行应该占的字节数

byteNum = ((width * 24 + 31) & ~31)>>3;

注意结果是字节数，如果想知道位数，还得x8
'''

'''
图片格式的必要性
如果将图像原始格式直接存储到文件中将会非常大，比如一个5000*5000 24位图，所占文件大小为5000*5000*3字节=71.5MB, 其大小非常可观。
如果用zip或rar之类的通用算法来压缩像素数据，得到的压缩比例通常不会太高，因为这些压缩算法没有针对图像数据结构进行特殊处理。
于是就有了jpeg,png等格式，同样是图像压缩算法jpeg和png也有不同的适用场景，具体在下文再阐述。'''

#所以可以总结如下: jpeg,png文件之于图像，就相当于zip,rar格式之于普通文件(用zip,rar格式对普通文件进行压缩)。
